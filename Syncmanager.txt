using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Collections;
using System;
using UnityEngine.EventSystems;

public class PlayerSyncManager : MonoBehaviour
{
    private struct PlayerState
    {
        public Vector3 Position;
        public float Rotation;
        public float ServerTimestamp;
        public Vector3 Velocity;
        public float ClientReceiveTime;
    }

    private struct PlayerDiagnostics
    {
        public float LastDesyncDistance;
        public int DesyncCount;
        public float LastJitter;
        public int JitterCount;
        public int TeleportCount;
        public float AverageRTT;
        public int BufferUnderflowCount;
        public int BufferOverflowCount;
        public float LastUpdateTime;
        public float LastCorrectionDistance;
        public int CorrectionCount;
        public float LastOverCorrectionDistance;
        public int OverCorrectionCount;
        public int NoPacketFrames;
        public float CurrentFPS;
        public float CurrentCorrectionStrength;
        public float CurrentBaseInterpTime;
        public int ReplayCorrectionCount;
        public float LastReplayTime;
    }

    [SerializeField] public float updateInterval = 0.0083f;
    [SerializeField] public float positionTolerance = 0.015f;
    [SerializeField] public float rotationTolerance = 0.4f;
    [SerializeField] public float initialMoveDelay = 0.04f;
    [SerializeField] public float initialCorrectGracePeriod = 0.05f;
    [SerializeField] public float movementThreshold = 0.002f;
    [SerializeField] public float inputSmoothing = 0.18f;
    [SerializeField] public float minMoveDistance = 0.0015f;
    [SerializeField] public float minRotationAngle = 0.08f;
    [SerializeField] public float baseInterpTime = 0.048f;
    [SerializeField] public float minInterpTime = 0.01f;
    [SerializeField] public float baseCorrectionSmoothing = 0.88f;
    [SerializeField] public float basePredictionFactor = 0.16f;
    [SerializeField] public float baseVelocitySmoothing = 0.29f;
    [SerializeField] public float baseJitterBufferDelay = 0.008f;
    [SerializeField] public float maxStateBufferSize = 5f;
    [SerializeField] public float minStateBufferSize = 3f;
    [SerializeField] public float maxVelocity = 13f;
    [SerializeField] public float rotationDamping = 0.95f;
    [SerializeField] public float teleportThreshold = 2.0f;
    [SerializeField] public float desyncCorrectionTime = 0.25f;
    [SerializeField] public float velocityPredictionDamping = 0.5f;
    [SerializeField] public float extrapolationLimiter = 0.2f;
    [SerializeField] public float maxCorrectionSpeed = 5.0f;
    [SerializeField] public float correctionDamping = 0.9f;
    [SerializeField] public float reCorrectionDelay = 0.5f;
    [SerializeField] public float maxExtrapolationTime = 0.1f;

    [SerializeField] public float maxCorrectionDistance = 1.0f;
    [SerializeField] public float overCorrectionThreshold = 0.5f;
    [SerializeField] public float reCorrectionThreshold = 0.3f;
    [SerializeField] public float correctionAggressiveness = 0.7f;
    [SerializeField] public float predictionAdjustmentFactor = 0.2f;
    [SerializeField] public float desyncToleranceMultiplier = 1.5f;

    [SerializeField] private float maxSpeed = 4.5f;
    [SerializeField] private float minSpeed = 0f;
    [SerializeField] private float boostSpeedMultiplier = 2f;
    [SerializeField] private float rotationSpeed = 180f;
    [SerializeField] private float leftXPosition = -21.4f;
    [SerializeField] private float rightXPosition = 47.42f;
    [SerializeField] private float topYPosition = 21.15f;
    [SerializeField] private float bottomYPosition = -48.3f;
    private const float HEALTH_BAR_OFFSET = 0.5f;

    [SerializeField] private Button toggleButton;
    [SerializeField] private GameObject lowLevelSettingsPanel1;
    [SerializeField] private Button resetButton1;
    [SerializeField] private GameObject variableEntryPrefab;
    [SerializeField] private Transform contentParent1;
    [SerializeField] private float entrySpacing = 15f;
    [SerializeField] private DotShooter dotShooter;
    [SerializeField] private Button diagnosticsToggleButton;
    [SerializeField] private GameObject diagnosticsPanel;
    [SerializeField] private Transform diagnosticsContentParent;
    [SerializeField] private GameObject diagnosticsEntryPrefab;
    [SerializeField] private float diagnosticsEntrySpacing = 15f;
    [SerializeField] private Button highLevelToggleButton;
    [SerializeField] private GameObject highLevelSettingsPanel;
    [SerializeField] private Button highLevelResetButton;
    [SerializeField] private Transform highLevelContentParent;
    [SerializeField] private Button lowLevel2ToggleButton;
    [SerializeField] private GameObject lowLevelSettingsPanel2;
    [SerializeField] private Button lowLevel2ResetButton;
    [SerializeField] private Transform lowLevel2ContentParent;
    [SerializeField] private Button hzToggleButton;
    private bool isLowLevelPanel1Active = false;
    private bool isHighLevelPanelActive = false;
    private bool isLowLevelPanel2Active = false;
    private bool isDiagnosticsPanelActive = false;
    private bool is120Hz = true;

    private Dictionary<int, PlayerDiagnostics> playerDiagnostics = new Dictionary<int, PlayerDiagnostics>();

    private Dictionary<int, float> autoAdjustedInterpTime = new Dictionary<int, float>();
    private Dictionary<int, float> autoAdjustedCorrectionSmoothing = new Dictionary<int, float>();
    private Dictionary<int, float> autoAdjustedPredictionFactor = new Dictionary<int, float>();
    private Dictionary<int, float> autoAdjustedVelocitySmoothing = new Dictionary<int, float>();
    private const float AUTO_DESYNC_MULTIPLIER = 1.5f;
    private const float AUTO_CORRECTION_BOOST = 1.2f;
    private const float AUTO_SMOOTHING_REDUCTION = 0.7f;
    private const int AUTO_NO_PACKET_THRESHOLD = 60;
    private const float AUTO_RTT_THRESHOLD = 0.15f;
    private const float AUTO_FPS_THRESHOLD = 30f;
    private Dictionary<int, Queue<(Vector3 Position, float Rotation, float Timestamp)>> replayBuffers = new Dictionary<int, Queue<(Vector3, float, float)>>();
    private const float REPLAY_BUFFER_DURATION = 3.0f;
    private const float LAG_SPIKE_RTT_THRESHOLD = 0.3f;
    private const float REPLAY_LERP_SPEED = 10f;

    private struct VariableConfig
    {
        public string Name;
        public float DefaultValue;
        public float Increment;
        public Action<float> Setter;
        public Func<float> Getter;
    }

    private List<VariableConfig> lowLevelVariableConfigs1 = new List<VariableConfig>();
    private List<VariableConfig> lowLevelVariableConfigs2 = new List<VariableConfig>();
    private List<VariableConfig> highLevelVariableConfigs = new List<VariableConfig>();
    private List<InputField> lowLevel1ValueInputFields = new List<InputField>();
    private List<InputField> lowLevel1NameInputFields = new List<InputField>();
    private List<Button> lowLevel1PlusButtons = new List<Button>();
    private List<Button> lowLevel1MinusButtons = new List<Button>();
    private List<InputField> lowLevel2ValueInputFields = new List<InputField>();
    private List<InputField> lowLevel2NameInputFields = new List<InputField>();
    private List<Button> lowLevel2PlusButtons = new List<Button>();
    private List<Button> lowLevel2MinusButtons = new List<Button>();
    private List<InputField> highLevelValueInputFields = new List<InputField>();
    private List<InputField> highLevelNameInputFields = new List<InputField>();
    private List<Button> highLevelPlusButtons = new List<Button>();
    private List<Button> highLevelMinusButtons = new List<Button>();
    private List<Text> diagnosticsTextFields = new List<Text>();

    private Joystick joystick;
    private GameNetworkManager networkManager;
    private float lastUpdateTime;
    private bool isBoosting = false;
    private float boostAmmoTimer = 0f;
    private float boostAmmoInterval = 0.1f;
    private bool isShootingRotation = false;
    private float shootingRotationTimer = 0f;
    private float shootingRotationDuration = 0.3f;
    private Vector3 lastSentPosition;
    private float lastSentRotation;
    private float spawnTime;
    private Vector3 spawnPosition;
    private bool hasMoved = false;
    private bool isFacingBackward = false;
    private float baseRotation = 0f;
    private Vector2 smoothedInput;
    private Vector2 lastInput;
    private Queue<(Vector3 Position, float Rotation, long Timestamp)> pendingMoves = new Queue<(Vector3, float, long)>();
    private float lastServerRejectionTime;
    private Vector3 playerPosition;
    private float playerRotation;
    private Dictionary<int, GameObject> otherPlayers = new Dictionary<int, GameObject>();
    private Dictionary<int, PlayerState> currentStates = new Dictionary<int, PlayerState>();
    private Dictionary<int, PlayerState> targetStates = new Dictionary<int, PlayerState>();
    private Dictionary<int, float> estimatedRTT = new Dictionary<int, float>();
    private Dictionary<int, Queue<PlayerState>> stateBuffers = new Dictionary<int, Queue<PlayerState>>();
    private Dictionary<int, float> lastPacketTimes = new Dictionary<int, float>();
    private Dictionary<int, float> lastDesyncTimes = new Dictionary<int, float>();
    private Dictionary<int, float> lastCorrectionTimes = new Dictionary<int, float>();
    private float lastFPSCheckTime;
    private int frameCounter;
    private float currentFPS;

    private Vector2 dragStartPosition;
    private bool isDragging = false;
    private InputField draggedInputField;
    private VariableConfig draggedConfig;

    public static PlayerSyncManager Instance { get; private set; }

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    void Start()
    {
        networkManager = GameNetworkManager.Instance;
        dotShooter = FindFirstObjectByType<DotShooter>();
        smoothedInput = Vector2.zero;
        lastInput = Vector2.zero;
        lastFPSCheckTime = Time.time;
        frameCounter = 0;
        currentFPS = 120f;
        InitializeLowLevelUI1();
        InitializeLowLevelUI2();
        InitializeHighLevelUI();
        InitializeDiagnosticsUI();
        InitializeHzToggle();
    }

    private void InitializeLowLevelUI1()
    {
        if (toggleButton == null || lowLevelSettingsPanel1 == null || resetButton1 == null || variableEntryPrefab == null || contentParent1 == null)
        {
            return;
        }

        lowLevelSettingsPanel1.SetActive(false);
        toggleButton.onClick.AddListener(ToggleLowLevelSettingsPanel1);
        resetButton1.onClick.AddListener(ResetLowLevel1ToDefaults);

        RectTransform contentRect = contentParent1.GetComponent<RectTransform>();
        contentRect.anchorMin = new Vector2(0, 1);
        contentRect.anchorMax = new Vector2(1, 1);
        contentRect.pivot = new Vector2(0.5f, 1);
        contentRect.anchoredPosition = Vector2.zero;
        contentRect.sizeDelta = new Vector2(0, contentRect.sizeDelta.y);

        VerticalLayoutGroup layout = contentParent1.GetComponent<VerticalLayoutGroup>();
        if (!layout)
        {
            layout = contentParent1.gameObject.AddComponent<VerticalLayoutGroup>();
        }
        layout.childAlignment = TextAnchor.UpperLeft;
        layout.childForceExpandWidth = true;
        layout.childForceExpandHeight = false;
        layout.spacing = entrySpacing;
        layout.padding = new RectOffset(15, 15, 15, 15);

        ContentSizeFitter fitter = contentParent1.GetComponent<ContentSizeFitter>();
        if (!fitter)
        {
            fitter = contentParent1.gameObject.AddComponent<ContentSizeFitter>();
        }
        fitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;

        lowLevelVariableConfigs1 = new List<VariableConfig>
        {
            new VariableConfig { Name = "updateInterval", DefaultValue = 0.0083f, Increment = 0.0001f, Setter = v => updateInterval = v, Getter = () => updateInterval },
            new VariableConfig { Name = "positionTolerance", DefaultValue = 0.015f, Increment = 0.001f, Setter = v => positionTolerance = v, Getter = () => positionTolerance },
            new VariableConfig { Name = "rotationTolerance", DefaultValue = 0.4f, Increment = 0.01f, Setter = v => rotationTolerance = v, Getter = () => rotationTolerance },
            new VariableConfig { Name = "teleportThreshold", DefaultValue = 2.0f, Increment = 0.1f, Setter = v => teleportThreshold = v, Getter = () => teleportThreshold },
            new VariableConfig { Name = "initialMoveDelay", DefaultValue = 0.04f, Increment = 0.001f, Setter = v => initialMoveDelay = v, Getter = () => initialMoveDelay },
            new VariableConfig { Name = "initialCorrectGracePeriod", DefaultValue = 0.05f, Increment = 0.001f, Setter = v => initialCorrectGracePeriod = v, Getter = () => initialCorrectGracePeriod },
            new VariableConfig { Name = "movementThreshold", DefaultValue = 0.002f, Increment = 0.0001f, Setter = v => movementThreshold = v, Getter = () => movementThreshold },
            new VariableConfig { Name = "minMoveDistance", DefaultValue = 0.0015f, Increment = 0.0001f, Setter = v => minMoveDistance = v, Getter = () => minMoveDistance },
            new VariableConfig { Name = "minRotationAngle", DefaultValue = 0.08f, Increment = 0.01f, Setter = v => minRotationAngle = v, Getter = () => minRotationAngle },
            new VariableConfig { Name = "inputSmoothing", DefaultValue = 0.18f, Increment = 0.01f, Setter = v => inputSmoothing = v, Getter = () => inputSmoothing },
            new VariableConfig { Name = "baseInterpTime", DefaultValue = 0.048f, Increment = 0.001f, Setter = v => baseInterpTime = v, Getter = () => baseInterpTime },
            new VariableConfig { Name = "minInterpTime", DefaultValue = 0.01f, Increment = 0.001f, Setter = v => minInterpTime = v, Getter = () => minInterpTime },
            new VariableConfig { Name = "rotationDamping", DefaultValue = 0.95f, Increment = 0.01f, Setter = v => rotationDamping = v, Getter = () => rotationDamping },
            new VariableConfig { Name = "basePredictionFactor", DefaultValue = 0.16f, Increment = 0.01f, Setter = v => basePredictionFactor = v, Getter = () => basePredictionFactor },
            new VariableConfig { Name = "baseVelocitySmoothing", DefaultValue = 0.29f, Increment = 0.01f, Setter = v => baseVelocitySmoothing = v, Getter = () => baseVelocitySmoothing },
            new VariableConfig { Name = "velocityPredictionDamping", DefaultValue = 0.5f, Increment = 0.01f, Setter = v => velocityPredictionDamping = v, Getter = () => velocityPredictionDamping },
            new VariableConfig { Name = "extrapolationLimiter", DefaultValue = 0.2f, Increment = 0.01f, Setter = v => extrapolationLimiter = v, Getter = () => extrapolationLimiter },
            new VariableConfig { Name = "baseCorrectionSmoothing", DefaultValue = 0.88f, Increment = 0.01f, Setter = v => baseCorrectionSmoothing = v, Getter = () => baseCorrectionSmoothing },
            new VariableConfig { Name = "desyncCorrectionTime", DefaultValue = 0.25f, Increment = 0.01f, Setter = v => desyncCorrectionTime = v, Getter = () => desyncCorrectionTime },
            new VariableConfig { Name = "baseJitterBufferDelay", DefaultValue = 0.008f, Increment = 0.001f, Setter = v => baseJitterBufferDelay = v, Getter = () => baseJitterBufferDelay },
            new VariableConfig { Name = "minStateBufferSize", DefaultValue = 3f, Increment = 1f, Setter = v => minStateBufferSize = v, Getter = () => minStateBufferSize },
            new VariableConfig { Name = "maxStateBufferSize", DefaultValue = 5f, Increment = 1f, Setter = v => maxStateBufferSize = v, Getter = () => maxStateBufferSize }
        };

        foreach (Transform child in contentParent1)
        {
            Destroy(child.gameObject);
        }
        lowLevel1ValueInputFields.Clear();
        lowLevel1NameInputFields.Clear();
        lowLevel1PlusButtons.Clear();
        lowLevel1MinusButtons.Clear();

        foreach (var config in lowLevelVariableConfigs1)
        {
            GameObject entry = Instantiate(variableEntryPrefab, contentParent1);
            RectTransform entryRect = entry.GetComponent<RectTransform>();
            entryRect.localScale = Vector3.one;
            entryRect.anchoredPosition3D = new Vector3(entryRect.anchoredPosition3D.x, entryRect.anchoredPosition3D.y, 0);
            entryRect.anchorMin = new Vector2(0, 1);
            entryRect.anchorMax = new Vector2(1, 1);
            entryRect.pivot = new Vector2(0.5f, 1);

            InputField nameField = entry.transform.Find("NameField")?.GetComponent<InputField>();
            InputField valueField = entry.transform.Find("ValueField")?.GetComponent<InputField>();
            Button plusButton = entry.transform.Find("PlusButton")?.GetComponent<Button>();
            Button minusButton = entry.transform.Find("MinusButton")?.GetComponent<Button>();

            if (nameField == null || valueField == null || plusButton == null || minusButton == null)
            {
                continue;
            }

            nameField.text = config.Name;
            nameField.interactable = false;
            lowLevel1NameInputFields.Add(nameField);

            valueField.text = config.Getter().ToString("F4");
            lowLevel1ValueInputFields.Add(valueField);
            valueField.onEndEdit.AddListener((value) =>
            {
                if (float.TryParse(value, out float newValue))
                {
                    config.Setter(newValue);
                    valueField.text = newValue.ToString("F4");
                }
                else
                {
                    valueField.text = config.Getter().ToString("F4");
                }
            });

            EventTrigger nameTrigger = nameField.gameObject.AddComponent<EventTrigger>();
            EventTrigger valueTrigger = valueField.gameObject.AddComponent<EventTrigger>();

            AddDragEvents(nameTrigger, valueField, config);
            AddDragEvents(valueTrigger, valueField, config);

            plusButton.onClick.AddListener(() =>
            {
                float current = config.Getter();
                float newValue = current + config.Increment;
                config.Setter(newValue);
                valueField.text = newValue.ToString("F4");
            });
            minusButton.onClick.AddListener(() =>
            {
                float current = config.Getter();
                float newValue = current - config.Increment;
                config.Setter(newValue);
                valueField.text = newValue.ToString("F4");
            });

            lowLevel1PlusButtons.Add(plusButton);
            lowLevel1MinusButtons.Add(minusButton);
        }

        LayoutRebuilder.ForceRebuildLayoutImmediate(contentRect);
        Canvas.ForceUpdateCanvases();
    }

    private void InitializeLowLevelUI2()
    {
        if (lowLevel2ToggleButton == null || lowLevelSettingsPanel2 == null || lowLevel2ResetButton == null || variableEntryPrefab == null || lowLevel2ContentParent == null)
        {
            return;
        }

        lowLevelSettingsPanel2.SetActive(false);
        lowLevel2ToggleButton.onClick.AddListener(ToggleLowLevelSettingsPanel2);
        lowLevel2ResetButton.onClick.AddListener(ResetLowLevel2ToDefaults);

        RectTransform contentRect = lowLevel2ContentParent.GetComponent<RectTransform>();
        contentRect.anchorMin = new Vector2(0, 1);
        contentRect.anchorMax = new Vector2(1, 1);
        contentRect.pivot = new Vector2(0.5f, 1);
        contentRect.anchoredPosition = Vector2.zero;
        contentRect.sizeDelta = new Vector2(0, contentRect.sizeDelta.y);

        VerticalLayoutGroup layout = lowLevel2ContentParent.GetComponent<VerticalLayoutGroup>();
        if (!layout)
        {
            layout = lowLevel2ContentParent.gameObject.AddComponent<VerticalLayoutGroup>();
        }
        layout.childAlignment = TextAnchor.UpperLeft;
        layout.childForceExpandWidth = true;
        layout.childForceExpandHeight = false;
        layout.spacing = entrySpacing;
        layout.padding = new RectOffset(15, 15, 15, 15);

        ContentSizeFitter fitter = lowLevel2ContentParent.GetComponent<ContentSizeFitter>();
        if (!fitter)
        {
            fitter = lowLevel2ContentParent.gameObject.AddComponent<ContentSizeFitter>();
        }
        fitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;

        lowLevelVariableConfigs2 = new List<VariableConfig>
        {
            new VariableConfig { Name = "maxCorrectionSpeed", DefaultValue = 5.0f, Increment = 0.1f, Setter = v => maxCorrectionSpeed = v, Getter = () => maxCorrectionSpeed },
            new VariableConfig { Name = "correctionDamping", DefaultValue = 0.9f, Increment = 0.01f, Setter = v => correctionDamping = v, Getter = () => correctionDamping },
            new VariableConfig { Name = "reCorrectionDelay", DefaultValue = 0.5f, Increment = 0.01f, Setter = v => reCorrectionDelay = v, Getter = () => reCorrectionDelay },
            new VariableConfig { Name = "maxExtrapolationTime", DefaultValue = 0.1f, Increment = 0.01f, Setter = v => maxExtrapolationTime = v, Getter = () => maxExtrapolationTime }
        };

        foreach (Transform child in lowLevel2ContentParent)
        {
            Destroy(child.gameObject);
        }
        lowLevel2ValueInputFields.Clear();
        lowLevel2NameInputFields.Clear();
        lowLevel2PlusButtons.Clear();
        lowLevel2MinusButtons.Clear();

        foreach (var config in lowLevelVariableConfigs2)
        {
            GameObject entry = Instantiate(variableEntryPrefab, lowLevel2ContentParent);
            RectTransform entryRect = entry.GetComponent<RectTransform>();
            entryRect.localScale = Vector3.one;
            entryRect.anchoredPosition3D = new Vector3(entryRect.anchoredPosition3D.x, entryRect.anchoredPosition3D.y, 0);
            entryRect.anchorMin = new Vector2(0, 1);
            entryRect.anchorMax = new Vector2(1, 1);
            entryRect.pivot = new Vector2(0.5f, 1);

            InputField nameField = entry.transform.Find("NameField")?.GetComponent<InputField>();
            InputField valueField = entry.transform.Find("ValueField")?.GetComponent<InputField>();
            Button plusButton = entry.transform.Find("PlusButton")?.GetComponent<Button>();
            Button minusButton = entry.transform.Find("MinusButton")?.GetComponent<Button>();

            if (nameField == null || valueField == null || plusButton == null || minusButton == null)
            {
                continue;
            }

            nameField.text = config.Name;
            nameField.interactable = false;
            lowLevel2NameInputFields.Add(nameField);

            valueField.text = config.Getter().ToString("F4");
            lowLevel2ValueInputFields.Add(valueField);
            valueField.onEndEdit.AddListener((value) =>
            {
                if (float.TryParse(value, out float newValue))
                {
                    config.Setter(newValue);
                    valueField.text = newValue.ToString("F4");
                }
                else
                {
                    valueField.text = config.Getter().ToString("F4");
                }
            });

            EventTrigger nameTrigger = nameField.gameObject.AddComponent<EventTrigger>();
            EventTrigger valueTrigger = valueField.gameObject.AddComponent<EventTrigger>();

            AddDragEvents(nameTrigger, valueField, config);
            AddDragEvents(valueTrigger, valueField, config);

            plusButton.onClick.AddListener(() =>
            {
                float current = config.Getter();
                float newValue = current + config.Increment;
                config.Setter(newValue);
                valueField.text = newValue.ToString("F4");
            });
            minusButton.onClick.AddListener(() =>
            {
                float current = config.Getter();
                float newValue = current - config.Increment;
                config.Setter(newValue);
                valueField.text = newValue.ToString("F4");
            });

            lowLevel2PlusButtons.Add(plusButton);
            lowLevel2MinusButtons.Add(minusButton);
        }

        LayoutRebuilder.ForceRebuildLayoutImmediate(contentRect);
        Canvas.ForceUpdateCanvases();
    }

    private void InitializeHighLevelUI()
    {
        if (highLevelToggleButton == null || highLevelSettingsPanel == null || highLevelResetButton == null || variableEntryPrefab == null || highLevelContentParent == null)
        {
            return;
        }

        highLevelSettingsPanel.SetActive(false);
        highLevelToggleButton.onClick.AddListener(ToggleHighLevelSettingsPanel);
        highLevelResetButton.onClick.AddListener(ResetHighLevelToDefaults);

        RectTransform contentRect = highLevelContentParent.GetComponent<RectTransform>();
        contentRect.anchorMin = new Vector2(0, 1);
        contentRect.anchorMax = new Vector2(1, 1);
        contentRect.pivot = new Vector2(0.5f, 1);
        contentRect.anchoredPosition = Vector2.zero;
        contentRect.sizeDelta = new Vector2(0, contentRect.sizeDelta.y);

        VerticalLayoutGroup layout = highLevelContentParent.GetComponent<VerticalLayoutGroup>();
        if (!layout)
        {
            layout = highLevelContentParent.gameObject.AddComponent<VerticalLayoutGroup>();
        }
        layout.childAlignment = TextAnchor.UpperLeft;
        layout.childForceExpandWidth = true;
        layout.childForceExpandHeight = false;
        layout.spacing = entrySpacing;
        layout.padding = new RectOffset(15, 15, 15, 15);

        ContentSizeFitter fitter = highLevelContentParent.GetComponent<ContentSizeFitter>();
        if (!fitter)
        {
            fitter = highLevelContentParent.gameObject.AddComponent<ContentSizeFitter>();
        }
        fitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;

        highLevelVariableConfigs = new List<VariableConfig>
        {
            new VariableConfig { Name = "maxCorrectionDistance", DefaultValue = 1.0f, Increment = 0.1f, Setter = v => maxCorrectionDistance = v, Getter = () => maxCorrectionDistance },
            new VariableConfig { Name = "overCorrectionThreshold", DefaultValue = 0.5f, Increment = 0.01f, Setter = v => overCorrectionThreshold = v, Getter = () => overCorrectionThreshold },
            new VariableConfig { Name = "reCorrectionThreshold", DefaultValue = 0.3f, Increment = 0.01f, Setter = v => reCorrectionThreshold = v, Getter = () => reCorrectionThreshold },
            new VariableConfig { Name = "correctionAggressiveness", DefaultValue = 0.7f, Increment = 0.01f, Setter = v => correctionAggressiveness = v, Getter = () => correctionAggressiveness },
            new VariableConfig { Name = "predictionAdjustmentFactor", DefaultValue = 0.2f, Increment = 0.01f, Setter = v => predictionAdjustmentFactor = v, Getter = () => predictionAdjustmentFactor },
            new VariableConfig { Name = "desyncToleranceMultiplier", DefaultValue = 1.5f, Increment = 0.1f, Setter = v => desyncToleranceMultiplier = v, Getter = () => desyncToleranceMultiplier }
        };

        foreach (Transform child in highLevelContentParent)
        {
            Destroy(child.gameObject);
        }
        highLevelValueInputFields.Clear();
        highLevelNameInputFields.Clear();
        highLevelPlusButtons.Clear();
        highLevelMinusButtons.Clear();

        foreach (var config in highLevelVariableConfigs)
        {
            GameObject entry = Instantiate(variableEntryPrefab, highLevelContentParent);
            RectTransform entryRect = entry.GetComponent<RectTransform>();
            entryRect.localScale = Vector3.one;
            entryRect.anchoredPosition3D = new Vector3(entryRect.anchoredPosition3D.x, entryRect.anchoredPosition3D.y, 0);
            entryRect.anchorMin = new Vector2(0, 1);
            entryRect.anchorMax = new Vector2(1, 1);
            entryRect.pivot = new Vector2(0.5f, 1);

            InputField nameField = entry.transform.Find("NameField")?.GetComponent<InputField>();
            InputField valueField = entry.transform.Find("ValueField")?.GetComponent<InputField>();
            Button plusButton = entry.transform.Find("PlusButton")?.GetComponent<Button>();
            Button minusButton = entry.transform.Find("MinusButton")?.GetComponent<Button>();

            if (nameField == null || valueField == null || plusButton == null || minusButton == null)
            {
                continue;
            }

            nameField.text = config.Name;
            nameField.interactable = false;
            highLevelNameInputFields.Add(nameField);

            valueField.text = config.Getter().ToString("F4");
            highLevelValueInputFields.Add(valueField);
            valueField.onEndEdit.AddListener((value) =>
            {
                if (float.TryParse(value, out float newValue))
                {
                    config.Setter(newValue);
                    valueField.text = newValue.ToString("F4");
                }
                else
                {
                    valueField.text = config.Getter().ToString("F4");
                }
            });

            EventTrigger nameTrigger = nameField.gameObject.AddComponent<EventTrigger>();
            EventTrigger valueTrigger = valueField.gameObject.AddComponent<EventTrigger>();

            AddDragEvents(nameTrigger, valueField, config);
            AddDragEvents(valueTrigger, valueField, config);

            plusButton.onClick.AddListener(() =>
            {
                float current = config.Getter();
                float newValue = current + config.Increment;
                config.Setter(newValue);
                valueField.text = newValue.ToString("F4");
            });
            minusButton.onClick.AddListener(() =>
            {
                float current = config.Getter();
                float newValue = current - config.Increment;
                config.Setter(newValue);
                valueField.text = newValue.ToString("F4");
            });

            highLevelPlusButtons.Add(plusButton);
            highLevelMinusButtons.Add(minusButton);
        }

        LayoutRebuilder.ForceRebuildLayoutImmediate(contentRect);
        Canvas.ForceUpdateCanvases();
    }

    private void InitializeDiagnosticsUI()
    {
        if (diagnosticsToggleButton == null || diagnosticsPanel == null || diagnosticsEntryPrefab == null || diagnosticsContentParent == null)
        {
            return;
        }

        diagnosticsPanel.SetActive(false);
        diagnosticsToggleButton.onClick.AddListener(ToggleDiagnosticsPanel);

        RectTransform contentRect = diagnosticsContentParent.GetComponent<RectTransform>();
        contentRect.anchorMin = new Vector2(0, 1);
        contentRect.anchorMax = new Vector2(1, 1);
        contentRect.pivot = new Vector2(0.5f, 1);
        contentRect.anchoredPosition = Vector2.zero;
        contentRect.sizeDelta = new Vector2(0, contentRect.sizeDelta.y);

        VerticalLayoutGroup layout = diagnosticsContentParent.GetComponent<VerticalLayoutGroup>();
        if (!layout)
        {
            layout = diagnosticsContentParent.gameObject.AddComponent<VerticalLayoutGroup>();
        }
        layout.childAlignment = TextAnchor.UpperLeft;
        layout.childForceExpandWidth = true;
        layout.childForceExpandHeight = false;
        layout.spacing = diagnosticsEntrySpacing;
        layout.padding = new RectOffset(15, 15, 15, 15);

        ContentSizeFitter fitter = diagnosticsContentParent.GetComponent<ContentSizeFitter>();
        if (!fitter)
        {
            fitter = diagnosticsContentParent.gameObject.AddComponent<ContentSizeFitter>();
        }
        fitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;

        foreach (Transform child in diagnosticsContentParent)
        {
            Destroy(child.gameObject);
        }
        diagnosticsTextFields.Clear();

        UpdateDiagnosticsUI();

        LayoutRebuilder.ForceRebuildLayoutImmediate(contentRect);
        Canvas.ForceUpdateCanvases();
    }

    private void InitializeHzToggle()
    {
        if (hzToggleButton == null)
        {
            return;
        }

        hzToggleButton.onClick.AddListener(ToggleHzMode);
        UpdateHzModeParameters();
        UpdateHzButtonText();
    }

    private void AddDragEvents(EventTrigger trigger, InputField valueField, VariableConfig config)
    {
        EventTrigger.Entry beginDragEntry = new EventTrigger.Entry { eventID = EventTriggerType.BeginDrag };
        beginDragEntry.callback.AddListener((eventData) =>
        {
            dragStartPosition = ((PointerEventData)eventData).position;
            isDragging = true;
            draggedInputField = valueField;
            draggedConfig = config;
        });
        trigger.triggers.Add(beginDragEntry);

        EventTrigger.Entry dragEntry = new EventTrigger.Entry { eventID = EventTriggerType.Drag };
        dragEntry.callback.AddListener((eventData) =>
        {
            if (isDragging && draggedInputField == valueField)
            {
                Vector2 currentPosition = ((PointerEventData)eventData).position;
                float dragDistance = currentPosition.x - dragStartPosition.x;
                float sensitivity = 50f;
                float change = dragDistance / sensitivity * config.Increment;
                float currentValue = config.Getter();
                float newValue = currentValue + change;
                config.Setter(newValue);
                valueField.text = newValue.ToString("F4");
                dragStartPosition = currentPosition;
            }
        });
        trigger.triggers.Add(dragEntry);

        EventTrigger.Entry endDragEntry = new EventTrigger.Entry { eventID = EventTriggerType.EndDrag };
        endDragEntry.callback.AddListener((eventData) =>
        {
            isDragging = false;
            draggedInputField = null;
        });
        trigger.triggers.Add(endDragEntry);
    }

    private void ToggleLowLevelSettingsPanel1()
    {
        isLowLevelPanel1Active = !isLowLevelPanel1Active;
        lowLevelSettingsPanel1.SetActive(isLowLevelPanel1Active);

        UpdatePlayerInputState();

        if (isLowLevelPanel1Active)
        {
            RectTransform panelRect = lowLevelSettingsPanel1.GetComponent<RectTransform>();
            panelRect.anchoredPosition = Vector2.zero;
        }
    }

    private void ToggleLowLevelSettingsPanel2()
    {
        isLowLevelPanel2Active = !isLowLevelPanel2Active;
        lowLevelSettingsPanel2.SetActive(isLowLevelPanel2Active);

        UpdatePlayerInputState();

        if (isLowLevelPanel2Active)
        {
            RectTransform panelRect = lowLevelSettingsPanel2.GetComponent<RectTransform>();
            panelRect.anchoredPosition = Vector2.zero;
        }
    }

    private void ToggleHighLevelSettingsPanel()
    {
        isHighLevelPanelActive = !isHighLevelPanelActive;
        highLevelSettingsPanel.SetActive(isHighLevelPanelActive);

        UpdatePlayerInputState();

        if (isHighLevelPanelActive)
        {
            RectTransform panelRect = highLevelSettingsPanel.GetComponent<RectTransform>();
            panelRect.anchoredPosition = Vector2.zero;
        }
    }

    private void ToggleDiagnosticsPanel()
    {
        isDiagnosticsPanelActive = !isDiagnosticsPanelActive;
        diagnosticsPanel.SetActive(isDiagnosticsPanelActive);

        UpdatePlayerInputState();

        if (isDiagnosticsPanelActive)
        {
            RectTransform panelRect = diagnosticsPanel.GetComponent<RectTransform>();
            panelRect.anchoredPosition = Vector2.zero;
            UpdateDiagnosticsUI();
        }
    }

    private void UpdatePlayerInputState()
    {
        bool inputEnabled = !isLowLevelPanel1Active && !isHighLevelPanelActive && !isLowLevelPanel2Active && !isDiagnosticsPanelActive;
        if (dotShooter != null)
        {
            dotShooter.enabled = inputEnabled;
        }

        GameObject[] players = GameObject.FindGameObjectsWithTag("Player");
        foreach (GameObject player in players)
        {
            PlayerMovement movement = player.GetComponent<PlayerMovement>();
            if (movement != null)
            {
                movement.enabled = inputEnabled;
            }
        }
    }

    private void ToggleHzMode()
    {
        is120Hz = !is120Hz;
        UpdateHzModeParameters();
        UpdateHzButtonText();
        UpdateUIValues();
    }

    private void UpdateHzModeParameters()
    {
        if (is120Hz)
        {
            updateInterval = 0.0083f;
            inputSmoothing = 0.18f;
            baseInterpTime = 0.048f;
            baseJitterBufferDelay = 0.008f;
            minStateBufferSize = 3f;
            maxStateBufferSize = 5f;
            maxExtrapolationTime = 0.1f;
        }
        else
        {
            updateInterval = 0.0167f;
            inputSmoothing = 0.36f;
            baseInterpTime = 0.096f;
            baseJitterBufferDelay = 0.016f;
            minStateBufferSize = 2f;
            maxStateBufferSize = 4f;
            maxExtrapolationTime = 0.2f;
        }
    }

    private void UpdateHzButtonText()
    {
        Text buttonText = hzToggleButton.GetComponentInChildren<Text>();
        if (buttonText != null)
        {
            buttonText.text = is120Hz ? "120Hz" : "60Hz";
        }
    }

    private void UpdateUIValues()
    {
        for (int i = 0; i < lowLevel1ValueInputFields.Count; i++)
        {
            lowLevel1ValueInputFields[i].text = lowLevelVariableConfigs1[i].Getter().ToString("F4");
        }
        for (int i = 0; i < lowLevel2ValueInputFields.Count; i++)
        {
            lowLevel2ValueInputFields[i].text = lowLevelVariableConfigs2[i].Getter().ToString("F4");
        }
    }

    private void ResetLowLevel1ToDefaults()
    {
        foreach (var config in lowLevelVariableConfigs1)
        {
            config.Setter(config.DefaultValue);
        }
        for (int i = 0; i < lowLevel1ValueInputFields.Count; i++)
        {
            lowLevel1ValueInputFields[i].text = lowLevelVariableConfigs1[i].Getter().ToString("F4");
        }
    }

    private void ResetLowLevel2ToDefaults()
    {
        foreach (var config in lowLevelVariableConfigs2)
        {
            config.Setter(config.DefaultValue);
        }
        for (int i = 0; i < lowLevel2ValueInputFields.Count; i++)
        {
            lowLevel2ValueInputFields[i].text = lowLevelVariableConfigs2[i].Getter().ToString("F4");
        }
    }

    private void ResetHighLevelToDefaults()
    {
        foreach (var config in highLevelVariableConfigs)
        {
            config.Setter(config.DefaultValue);
        }
        for (int i = 0; i < highLevelValueInputFields.Count; i++)
        {
            highLevelValueInputFields[i].text = highLevelVariableConfigs[i].Getter().ToString("F4");
        }
    }

    private void UpdateDiagnosticsUI()
    {
        foreach (Transform child in diagnosticsContentParent)
        {
            Destroy(child.gameObject);
        }
        diagnosticsTextFields.Clear();

        foreach (var id in playerDiagnostics.Keys)
        {
            var diagnostics = playerDiagnostics[id];
            GameObject entry = Instantiate(diagnosticsEntryPrefab, diagnosticsContentParent);
            RectTransform entryRect = entry.GetComponent<RectTransform>();
            entryRect.localScale = Vector3.one;
            entryRect.anchoredPosition3D = new Vector3(entryRect.anchoredPosition3D.x, entryRect.anchoredPosition3D.y, 0);
            entryRect.anchorMin = new Vector2(0, 1);
            entryRect.anchorMax = new Vector2(1, 1);
            entryRect.pivot = new Vector2(0.5f, 1);

            Text textField = entry.GetComponentInChildren<Text>();
            if (textField == null)
            {
                continue;
            }

            textField.text = $"Player {id}\n" +
                             $"Last Desync Distance: {diagnostics.LastDesyncDistance:F4}\n" +
                             $"Desync Count: {diagnostics.DesyncCount}\n" +
                             $"Last Jitter: {diagnostics.LastJitter:F4}\n" +
                             $"Jitter Count: {diagnostics.JitterCount}\n" +
                             $"Teleport Count: {diagnostics.TeleportCount}\n" +
                             $"Current RTT: {diagnostics.AverageRTT:F4}\n" +
                             $"Buffer Underflow Count: {diagnostics.BufferUnderflowCount}\n" +
                             $"Buffer Overflow Count: {diagnostics.BufferOverflowCount}\n" +
                             $"Last Correction Distance: {diagnostics.LastCorrectionDistance:F4}\n" +
                             $"Correction Count: {diagnostics.CorrectionCount}\n" +
                             $"Last Over-Correction Distance: {diagnostics.LastOverCorrectionDistance:F4}\n" +
                             $"Over-Correction Count: {diagnostics.OverCorrectionCount}\n" +
                             $"No Packet Frames: {diagnostics.NoPacketFrames}\n" +
                             $"Current FPS: {diagnostics.CurrentFPS:F2}\n" +
                             $"Active Correction Strength: {diagnostics.CurrentCorrectionStrength:F4}\n" +
                             $"Current Base Interp Time: {diagnostics.CurrentBaseInterpTime:F4}\n" +
                             $"Replay Correction Count: {diagnostics.ReplayCorrectionCount}\n" +
                             $"Last Replay Time: {diagnostics.LastReplayTime:F4}\n" +
                             $"Last Update Time: {diagnostics.LastUpdateTime:F4}";
            diagnosticsTextFields.Add(textField);
        }

        LayoutRebuilder.ForceRebuildLayoutImmediate(diagnosticsContentParent.GetComponent<RectTransform>());
        Canvas.ForceUpdateCanvases();
    }

    public void InitializeLocalPlayer(GameObject localPlayer, Vector3 position, float rotation)
    {
        lastSentPosition = position;
        lastSentRotation = rotation;
        playerPosition = position;
        playerRotation = rotation;
        spawnPosition = position;
        spawnTime = Time.time;
        hasMoved = false;
        isFacingBackward = false;
        baseRotation = rotation;
        smoothedInput = Vector2.zero;
        lastInput = Vector2.zero;
        pendingMoves.Clear();
    }

    void Update()
    {
        if (networkManager == null || PlayerManagerClient.Instance.LocalPlayer == null)
        {
            return;
        }

        UpdateFPS();
        UpdateLocalPlayerMovement();
        UpdateOtherPlayers();
        UpdateDiagnostics();
    }

    private void UpdateFPS()
    {
        frameCounter++;
        if (Time.time - lastFPSCheckTime >= 1.0f)
        {
            currentFPS = frameCounter / (Time.time - lastFPSCheckTime);
            frameCounter = 0;
            lastFPSCheckTime = Time.time;
        }
    }

    private void UpdateDiagnostics()
    {
        foreach (var id in otherPlayers.Keys)
        {
            if (!otherPlayers.ContainsKey(id) || otherPlayers[id] == null) continue;

            if (!playerDiagnostics.ContainsKey(id))
            {
                playerDiagnostics[id] = new PlayerDiagnostics
                {
                    LastDesyncDistance = 0f,
                    DesyncCount = 0,
                    LastJitter = 0f,
                    JitterCount = 0,
                    TeleportCount = 0,
                    AverageRTT = estimatedRTT.ContainsKey(id) ? estimatedRTT[id] : 0.08f,
                    BufferUnderflowCount = 0,
                    BufferOverflowCount = 0,
                    LastUpdateTime = Time.time,
                    LastCorrectionDistance = 0f,
                    CorrectionCount = 0,
                    LastOverCorrectionDistance = 0f,
                    OverCorrectionCount = 0,
                    NoPacketFrames = 0,
                    CurrentFPS = currentFPS,
                    CurrentCorrectionStrength = baseCorrectionSmoothing,
                    CurrentBaseInterpTime = baseInterpTime,
                    ReplayCorrectionCount = 0,
                    LastReplayTime = 0f
                };
            }

            var diagnostics = playerDiagnostics[id];
            float currentTime = Time.time;

            if (stateBuffers.ContainsKey(id))
            {
                var buffer = stateBuffers[id];
                float rtt = estimatedRTT.ContainsKey(id) ? estimatedRTT[id] : 0.08f;
                int targetBufferSize = Mathf.RoundToInt(Mathf.Lerp(minStateBufferSize, maxStateBufferSize, rtt / 0.3f));

                if (buffer.Count < minStateBufferSize)
                {
                    diagnostics.BufferUnderflowCount++;
                }
                else if (buffer.Count > targetBufferSize)
                {
                    diagnostics.BufferOverflowCount++;
                }
            }

            if (estimatedRTT.ContainsKey(id))
            {
                diagnostics.AverageRTT = Mathf.Lerp(diagnostics.AverageRTT, estimatedRTT[id], 0.1f);
            }

            if (lastPacketTimes.ContainsKey(id))
            {
                float timeSinceLastPacket = currentTime - lastPacketTimes[id];
                diagnostics.NoPacketFrames = Mathf.RoundToInt(timeSinceLastPacket / Time.deltaTime);
            }

            diagnostics.CurrentFPS = currentFPS;

            if (targetStates.ContainsKey(id) && currentStates.ContainsKey(id))
            {
                var target = targetStates[id];
                var current = currentStates[id];
                float timeDelta = target.ServerTimestamp - current.ServerTimestamp;
                if (timeDelta > 0)
                {
                    Vector3 velocityChange = target.Velocity - current.Velocity;
                    float jitter = velocityChange.magnitude / timeDelta;
                    if (jitter > 10f)
                    {
                        diagnostics.LastJitter = jitter;
                        diagnostics.JitterCount++;
                    }
                }
            }

            playerDiagnostics[id] = diagnostics;
        }

        if (isDiagnosticsPanelActive)
        {
            UpdateDiagnosticsUI();
        }
    }

    private void ApplyAutoAdjustments(int id, float desyncDistance)
    {
        float rtt = estimatedRTT.ContainsKey(id) ? estimatedRTT[id] : 0.08f;
        var diagnostics = playerDiagnostics[id];

        if (!autoAdjustedInterpTime.ContainsKey(id))
            autoAdjustedInterpTime[id] = baseInterpTime;
        if (!autoAdjustedCorrectionSmoothing.ContainsKey(id))
            autoAdjustedCorrectionSmoothing[id] = baseCorrectionSmoothing;
        if (!autoAdjustedPredictionFactor.ContainsKey(id))
            autoAdjustedPredictionFactor[id] = basePredictionFactor;
        if (!autoAdjustedVelocitySmoothing.ContainsKey(id))
            autoAdjustedVelocitySmoothing[id] = baseVelocitySmoothing;

        float targetInterpTime = baseInterpTime;
        float targetCorrectionSmoothing = baseCorrectionSmoothing;
        float targetPredictionFactor = basePredictionFactor;
        float targetVelocitySmoothing = baseVelocitySmoothing;
        float targetJitterBufferDelay = is120Hz ? 0.008f : 0.016f;

        if (rtt > AUTO_RTT_THRESHOLD)
        {
            targetInterpTime = baseInterpTime * 1.5f;
            targetCorrectionSmoothing = baseCorrectionSmoothing * 1.3f;
        }

        if (desyncDistance > positionTolerance * AUTO_DESYNC_MULTIPLIER * desyncToleranceMultiplier)
        {
            targetCorrectionSmoothing *= AUTO_CORRECTION_BOOST;
            targetPredictionFactor = basePredictionFactor * 0.5f;
        }

        if (currentFPS < AUTO_FPS_THRESHOLD)
        {
            targetCorrectionSmoothing *= AUTO_SMOOTHING_REDUCTION;
            targetInterpTime *= AUTO_SMOOTHING_REDUCTION;
        }

        if (diagnostics.NoPacketFrames > AUTO_NO_PACKET_THRESHOLD || rtt > LAG_SPIKE_RTT_THRESHOLD)
        {
            if (otherPlayers.ContainsKey(id) && targetStates.ContainsKey(id))
            {
                StartCoroutine(HandleReplayCorrection(id));
                diagnostics.ReplayCorrectionCount++;
                diagnostics.LastReplayTime = Time.time;
                diagnostics.NoPacketFrames = 0;
                playerDiagnostics[id] = diagnostics;
            }
        }

        float jitterBufferScale = Mathf.Lerp(1f, 2f, rtt / 0.3f);
        targetJitterBufferDelay *= jitterBufferScale;

        float smoothingSpeed = 5f;
        autoAdjustedInterpTime[id] = Mathf.Lerp(autoAdjustedInterpTime[id], targetInterpTime, Time.deltaTime * smoothingSpeed);
        autoAdjustedCorrectionSmoothing[id] = Mathf.Lerp(autoAdjustedCorrectionSmoothing[id], targetCorrectionSmoothing, Time.deltaTime * smoothingSpeed);
        autoAdjustedPredictionFactor[id] = Mathf.Lerp(autoAdjustedPredictionFactor[id], targetPredictionFactor, Time.deltaTime * smoothingSpeed);
        autoAdjustedVelocitySmoothing[id] = Mathf.Lerp(autoAdjustedVelocitySmoothing[id], targetVelocitySmoothing, Time.deltaTime * smoothingSpeed);
        baseJitterBufferDelay = Mathf.Lerp(baseJitterBufferDelay, targetJitterBufferDelay, Time.deltaTime * smoothingSpeed);

        autoAdjustedInterpTime[id] = Mathf.Clamp(autoAdjustedInterpTime[id], minInterpTime, baseInterpTime * 2f);
        autoAdjustedCorrectionSmoothing[id] = Mathf.Clamp(autoAdjustedCorrectionSmoothing[id], 0.1f, 2f);
        autoAdjustedPredictionFactor[id] = Mathf.Clamp(autoAdjustedPredictionFactor[id], 0.01f, basePredictionFactor * 1.5f);
        autoAdjustedVelocitySmoothing[id] = Mathf.Clamp(autoAdjustedVelocitySmoothing[id], 0.1f, baseVelocitySmoothing * 1.5f);
        baseJitterBufferDelay = Mathf.Clamp(baseJitterBufferDelay, 0.004f, 0.1f);

        diagnostics.CurrentCorrectionStrength = autoAdjustedCorrectionSmoothing[id];
        diagnostics.CurrentBaseInterpTime = autoAdjustedInterpTime[id];
        playerDiagnostics[id] = diagnostics;
    }

    private void UpdateLocalPlayerMovement()
    {
        GameObject localPlayer = PlayerManagerClient.Instance.LocalPlayer;
        float currentRotation = localPlayer.transform.rotation.eulerAngles.z;
        Vector2 input = Vector2.zero;
        float rotationInput = 0f;
        bool useJoystick = false;

        if (joystick == null)
        {
            joystick = FindFirstObjectByType<Joystick>();
        }

        useJoystick = joystick != null && joystick.IsActive;

        if (useJoystick)
        {
            Vector2 rawInput = joystick.GetInput();
            smoothedInput = Vector2.Lerp(smoothedInput, rawInput, inputSmoothing / Time.deltaTime);
            lastInput = rawInput;
            input = smoothedInput;
            isBoosting = joystick.IsBoosting && GameNetworkManager.Instance.AmmoCount > 0 && rawInput != Vector2.zero;
        }
        else
        {
            if (Input.GetKey(KeyCode.A))
            {
                rotationInput = 1f;
            }
            if (Input.GetKey(KeyCode.D))
            {
                rotationInput = -1f;
            }
            if (Input.GetKeyDown(KeyCode.W) && !isShootingRotation)
            {
                isFacingBackward = false;
            }
            if (Input.GetKeyDown(KeyCode.S) && !isShootingRotation)
            {
                isFacingBackward = true;
            }
            if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.S))
            {
                input = new Vector2(0f, 1f);
                isBoosting = false;
            }
        }

        if (!isShootingRotation && rotationInput != 0f)
        {
            float rotationDelta = rotationInput * rotationSpeed * Time.deltaTime;
            baseRotation = (baseRotation + rotationDelta) % 360f;
        }

        currentRotation = isFacingBackward ? (baseRotation + 180f) % 360f : baseRotation;

        float baseSpeed = useJoystick ? Mathf.Lerp(minSpeed, maxSpeed, input.magnitude * input.magnitude) : maxSpeed;
        float speed = isBoosting ? baseSpeed * boostSpeedMultiplier : baseSpeed;
        Vector3 movement;
        if (useJoystick && input != Vector2.zero)
        {
            movement = input.normalized * speed * Time.deltaTime;
        }
        else
        {
            Vector3 direction = Quaternion.Euler(0, 0, currentRotation) * Vector3.up;
            movement = direction * input.y * speed * Time.deltaTime;
        }

        playerPosition += movement;
        playerPosition.x = Mathf.Clamp(playerPosition.x, leftXPosition, rightXPosition);
        playerPosition.y = Mathf.Clamp(playerPosition.y, bottomYPosition, topYPosition);
        playerRotation = currentRotation;

        localPlayer.transform.position = playerPosition;
        localPlayer.transform.rotation = Quaternion.Euler(0f, 0f, playerRotation);

        if (isShootingRotation)
        {
            shootingRotationTimer += Time.deltaTime;
            if (shootingRotationTimer >= shootingRotationDuration)
            {
                isShootingRotation = false;
            }
        }
        else if (useJoystick && input != Vector2.zero)
        {
            float rotation = Mathf.Atan2(input.y, input.x) * Mathf.Rad2Deg - 90f;
            playerRotation = rotation;
            localPlayer.transform.rotation = Quaternion.Euler(0f, 0f, rotation);
            baseRotation = rotation;
            isFacingBackward = false;
        }

        if (!hasMoved && Vector3.Distance(localPlayer.transform.position, spawnPosition) > movementThreshold)
        {
            hasMoved = true;
        }

        if (Time.time - spawnTime > initialMoveDelay && Time.time - lastUpdateTime >= updateInterval)
        {
            Vector3 currentPosition = playerPosition;
            float positionDelta = Vector3.Distance(currentPosition, lastSentPosition);
            float rotationDelta = Mathf.Abs(playerRotation - lastSentRotation);

            if (positionDelta > minMoveDistance || rotationDelta > minRotationAngle)
            {
                long timestamp = (long)((Time.time + networkManager.serverTimeOffset) * 1000f);
                pendingMoves.Clear();
                pendingMoves.Enqueue((currentPosition, playerRotation, timestamp));
            }

            if (pendingMoves.Count > 0)
            {
                (Vector3 sendPosition, float sendRotation, long sendTimestamp) = pendingMoves.Peek();
                string moveMessage = $"MOVE {networkManager.LocalPlayerID} {sendPosition.x:F2} {sendPosition.y:F2} {sendPosition.z:F2} {sendRotation:F2} {networkManager.PlayerToken} {sendTimestamp}";
                networkManager.SendNetworkMessage(moveMessage);
                lastSentPosition = sendPosition;
                lastSentRotation = sendRotation;
                lastUpdateTime = Time.time;
                pendingMoves.Dequeue();
            }
        }

        if (isBoosting)
        {
            boostAmmoTimer += Time.deltaTime;
            if (boostAmmoTimer >= boostAmmoInterval)
            {
                GameNetworkManager.Instance.AmmoCount -= 1;
                GameNetworkManager.Instance.PlayerAmmo[GameNetworkManager.Instance.LocalPlayerID] = GameNetworkManager.Instance.AmmoCount;
                GameNetworkManager.Instance.SendNetworkMessage($"AMMO {networkManager.LocalPlayerID} {GameNetworkManager.Instance.AmmoCount} {networkManager.PlayerToken}");
                boostAmmoTimer = 0f;

                if (GameNetworkManager.Instance.AmmoCount <= 0)
                {
                    isBoosting = false;
                    if (joystick != null) joystick.StopBoosting();
                }
            }
        }
        else
        {
            boostAmmoTimer = 0f;
        }
    }

    private void UpdateOtherPlayers()
    {
        foreach (var id in otherPlayers.Keys)
        {
            if (!otherPlayers.ContainsKey(id) || otherPlayers[id] == null) continue;

            if (!stateBuffers.ContainsKey(id) || stateBuffers[id].Count < 2) continue;

            var buffer = stateBuffers[id];
            float rtt = estimatedRTT.ContainsKey(id) ? estimatedRTT[id] : 0.08f;
            float jitterBufferDelay = Mathf.Clamp(baseJitterBufferDelay * (rtt / 0.08f), 0.01f, 0.1f);

            int targetBufferSize = Mathf.RoundToInt(Mathf.Lerp(minStateBufferSize, maxStateBufferSize, rtt / 0.3f));
            while (buffer.Count > targetBufferSize)
            {
                buffer.Dequeue();
            }

            while (buffer.Count > 1 && Time.time - buffer.Peek().ClientReceiveTime > jitterBufferDelay)
            {
                var state = buffer.Dequeue();
                currentStates[id] = targetStates[id];
                targetStates[id] = state;
            }

            if (!targetStates.ContainsKey(id) || !currentStates.ContainsKey(id)) continue;

            var target = targetStates[id];
            var current = currentStates[id];

            float serverTimeNow = Time.time + GameNetworkManager.Instance.serverTimeOffset;
            float interpTime = Mathf.Clamp(rtt * 0.5f, minInterpTime, autoAdjustedInterpTime[id] * (rtt / 0.08f));
            float t = Mathf.Clamp01((serverTimeNow - target.ServerTimestamp) / interpTime);

            float predictionFactor = Mathf.Lerp(autoAdjustedPredictionFactor[id] * 0.5f, autoAdjustedPredictionFactor[id], rtt / 0.2f) * predictionAdjustmentFactor;
            float predictionTime = Mathf.Min(interpTime * predictionFactor, Mathf.Min(extrapolationLimiter, maxExtrapolationTime));
            Vector3 predictedPos = target.Position + Vector3.ClampMagnitude(target.Velocity, maxVelocity) * predictionTime;

            float correctionSmoothing = Mathf.Lerp(autoAdjustedCorrectionSmoothing[id] * 0.5f, autoAdjustedCorrectionSmoothing[id] * 1.5f, rtt / 0.2f) * correctionAggressiveness;
            Vector3 newPos = Vector3.Lerp(current.Position, predictedPos, t);

            float rotationT = t * rotationDamping;
            Quaternion newRot = Quaternion.Slerp(
                Quaternion.Euler(0, 0, current.Rotation),
                Quaternion.Euler(0, 0, target.Rotation),
                rotationT
            );

            Vector3 currentPos = otherPlayers[id].transform.position;
            float desyncDistance = Vector3.Distance(currentPos, newPos);

            if (playerDiagnostics.ContainsKey(id))
            {
                var diagnostics = playerDiagnostics[id];
                diagnostics.LastDesyncDistance = desyncDistance;
                if (desyncDistance > positionTolerance * desyncToleranceMultiplier)
                {
                    diagnostics.DesyncCount++;
                }
                if (desyncDistance > teleportThreshold)
                {
                    diagnostics.TeleportCount++;
                }
                playerDiagnostics[id] = diagnostics;
            }

            ApplyAutoAdjustments(id, desyncDistance);

            if (desyncDistance > teleportThreshold)
            {
                newPos = predictedPos;
                otherPlayers[id].transform.rotation = Quaternion.Euler(0, 0, target.Rotation);
                currentStates[id] = target;
            }
            else if (desyncDistance > maxCorrectionDistance)
            {
                Vector3 correctionVector = predictedPos - currentPos;
                float correctionDistance = correctionVector.magnitude;
                Vector3 correctionDir = correctionVector.normalized;
                float correctionAmount = Mathf.Min(correctionDistance, maxCorrectionSpeed * Time.deltaTime);
                newPos = currentPos + correctionDir * correctionAmount * correctionSmoothing;

                if (playerDiagnostics.ContainsKey(id))
                {
                    var diagnostics = playerDiagnostics[id];
                    diagnostics.LastCorrectionDistance = correctionAmount;
                    diagnostics.CorrectionCount++;
                    if (correctionDistance > overCorrectionThreshold)
                    {
                        diagnostics.LastOverCorrectionDistance = correctionDistance;
                        diagnostics.OverCorrectionCount++;
                    }
                    playerDiagnostics[id] = diagnostics;
                }
            }
            else if (desyncDistance > positionTolerance * desyncToleranceMultiplier)
            {
                newPos = Vector3.Lerp(currentPos, newPos, correctionSmoothing * correctionDamping);
            }

            if (desyncDistance > positionTolerance * desyncToleranceMultiplier)
            {
                if (!lastDesyncTimes.ContainsKey(id))
                {
                    lastDesyncTimes[id] = Time.time;
                }
                else if (Time.time - lastDesyncTimes[id] > desyncCorrectionTime)
                {
                    if (!lastCorrectionTimes.ContainsKey(id) || Time.time - lastCorrectionTimes[id] > reCorrectionDelay)
                    {
                        if (desyncDistance > reCorrectionThreshold)
                        {
                            newPos = predictedPos;
                            otherPlayers[id].transform.rotation = Quaternion.Euler(0, 0, target.Rotation);
                            currentStates[id] = target;
                            lastDesyncTimes[id] = Time.time;
                            lastCorrectionTimes[id] = Time.time;

                            if (playerDiagnostics.ContainsKey(id))
                            {
                                var diagnostics = playerDiagnostics[id];
                                diagnostics.LastCorrectionDistance = desyncDistance;
                                diagnostics.CorrectionCount++;
                                playerDiagnostics[id] = diagnostics;
                            }
                        }
                    }
                }
            }
            else
            {
                lastDesyncTimes.Remove(id);
            }

            otherPlayers[id].transform.position = newPos;
            otherPlayers[id].transform.rotation = newRot;

            if (OtherPlayersManagerClient.Instance.HealthBars.ContainsKey(id) && OtherPlayersManagerClient.Instance.HealthBars[id] != null)
            {
                OtherPlayersManagerClient.Instance.HealthBars[id].transform.position = newPos + new Vector3(0, HEALTH_BAR_OFFSET, 0);
                OtherPlayersManagerClient.Instance.HealthBars[id].transform.rotation = Quaternion.identity;
            }

            if (t >= 1f)
            {
                currentStates[id] = new PlayerState
                {
                    Position = predictedPos,
                    Rotation = target.Rotation,
                    ServerTimestamp = target.ServerTimestamp,
                    Velocity = target.Velocity,
                    ClientReceiveTime = target.ClientReceiveTime
                };
            }
        }
    }

    public void SetTemporaryRotation(GameObject localPlayer, float rotation)
    {
        isShootingRotation = true;
        shootingRotationTimer = 0f;
        playerRotation = rotation;
        localPlayer.transform.rotation = Quaternion.Euler(0f, 0f, rotation);
        baseRotation = rotation;
        isFacingBackward = false;
    }

    public void CorrectPosition(GameObject localPlayer, Vector3 serverPosition, float serverRotation)
    {
        if (Time.time - spawnTime < initialCorrectGracePeriod &&
            Vector3.Distance(serverPosition, playerPosition) < positionTolerance * desyncToleranceMultiplier &&
            Mathf.Abs(serverRotation - playerRotation) < rotationTolerance)
        {
            return;
        }

        float desyncDistance = Vector3.Distance(playerPosition, serverPosition);
        if (desyncDistance > teleportThreshold)
        {
            playerPosition = serverPosition;
            playerRotation = serverRotation;
            localPlayer.transform.position = serverPosition;
            localPlayer.transform.rotation = Quaternion.Euler(0f, 0f, serverRotation);
            lastSentPosition = serverPosition;
            lastSentRotation = serverRotation;
            baseRotation = serverRotation;
            isFacingBackward = false;
            pendingMoves.Clear();
            lastServerRejectionTime = Time.time;
        }
        else if (desyncDistance > positionTolerance * desyncToleranceMultiplier ||
                 Mathf.Abs(serverRotation - playerRotation) > rotationTolerance)
        {
            StartCoroutine(LerpToServerPosition(localPlayer, serverPosition, serverRotation, desyncDistance));
            lastServerRejectionTime = Time.time;
            pendingMoves.Clear();
        }
    }

    private IEnumerator LerpToServerPosition(GameObject localPlayer, Vector3 targetPosition, float targetRotation, float desyncDistance)
    {
        float lerpTime = Mathf.Clamp(desyncDistance * 0.05f, 0.02f, 0.2f) / correctionAggressiveness;
        float elapsed = 0f;
        Vector3 startPosition = playerPosition;
        Quaternion startRotation = Quaternion.Euler(0f, 0f, playerRotation);
        Quaternion targetRotationQuat = Quaternion.Euler(0f, 0f, targetRotation);

        while (elapsed < lerpTime)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / lerpTime;
            t = t * t * (3f - 2f * t);
            playerPosition = Vector3.Lerp(startPosition, targetPosition, t);
            playerRotation = Quaternion.Slerp(startRotation, targetRotationQuat, t).eulerAngles.z;
            localPlayer.transform.position = playerPosition;
            localPlayer.transform.rotation = Quaternion.Euler(0f, 0f, playerRotation);
            yield return null;
        }

        playerPosition = targetPosition;
        playerRotation = targetRotation;
        localPlayer.transform.position = targetPosition;
        localPlayer.transform.rotation = targetRotationQuat;
        lastSentPosition = targetPosition;
        lastSentRotation = targetRotation;
        baseRotation = targetRotation;
        isFacingBackward = false;
    }

    private IEnumerator HandleReplayCorrection(int id)
    {
        if (!replayBuffers.ContainsKey(id) || replayBuffers[id].Count < 2 || !otherPlayers.ContainsKey(id) || !targetStates.ContainsKey(id))
        {
            yield break;
        }

        var buffer = replayBuffers[id];
        var targetState = targetStates[id];
        GameObject player = otherPlayers[id];

        float replayStartTime = Time.time;
        float replayDuration = Mathf.Min(0.5f, REPLAY_BUFFER_DURATION / 2f);
        float elapsed = 0f;

        while (buffer.Count > 1 && elapsed < replayDuration)
        {
            var (startPos, startRot, startTime) = buffer.Peek();
            var (nextPos, nextRot, nextTime) = buffer.ToArray()[1];

            float t = (Time.time - startTime) / (nextTime - startTime);
            t = Mathf.Clamp01(t);

            Vector3 interpolatedPos = Vector3.Lerp(startPos, nextPos, t);
            float interpolatedRot = Mathf.LerpAngle(startRot, nextRot, t);

            player.transform.position = Vector3.Lerp(player.transform.position, interpolatedPos, Time.deltaTime * REPLAY_LERP_SPEED);
            player.transform.rotation = Quaternion.Slerp(
                player.transform.rotation,
                Quaternion.Euler(0, 0, interpolatedRot),
                Time.deltaTime * REPLAY_LERP_SPEED);

            elapsed += Time.deltaTime;

            if (Time.time >= nextTime)
            {
                buffer.Dequeue();
            }

            yield return null;
        }

        player.transform.position = Vector3.Lerp(player.transform.position, targetState.Position, Time.deltaTime * REPLAY_LERP_SPEED);
        player.transform.rotation = Quaternion.Slerp(
            player.transform.rotation,
            Quaternion.Euler(0, 0, targetState.Rotation),
            Time.deltaTime * REPLAY_LERP_SPEED);

        currentStates[id] = targetStates[id];
    }

    public void UpdatePlayerPosition(int id, Vector3 position, float rotation, float serverTimestamp = 0f)
    {
        position.z = 0f;
        if (id == GameNetworkManager.Instance.LocalPlayerID)
        {
            if (PlayerManagerClient.Instance.LocalPlayer != null)
            {
                CorrectPosition(PlayerManagerClient.Instance.LocalPlayer, position, rotation);
                PlayerManagerClient.Instance.LastSentPosition = position;
                PlayerManagerClient.Instance.LastSentRotation = rotation;
            }
            return;
        }

        if (!otherPlayers.ContainsKey(id) || otherPlayers[id] == null)
        {
            return;
        }

        float rtt = estimatedRTT.ContainsKey(id) ? estimatedRTT[id] : 0.08f;
        float velocitySmoothing = Mathf.Lerp(
            autoAdjustedVelocitySmoothing.ContainsKey(id) ? autoAdjustedVelocitySmoothing[id] * 0.5f : baseVelocitySmoothing * 0.5f,
            autoAdjustedVelocitySmoothing.ContainsKey(id) ? autoAdjustedVelocitySmoothing[id] * 1.5f : baseVelocitySmoothing * 1.5f,
            rtt / 0.2f);
        velocitySmoothing = Mathf.Clamp(velocitySmoothing, 0.1f, baseVelocitySmoothing * 1.5f);

        Vector3 velocity = Vector3.zero;
        if (targetStates.ContainsKey(id))
        {
            var lastState = targetStates[id];
            float timeDelta = serverTimestamp - lastState.ServerTimestamp;
            if (timeDelta > 0)
            {
                Vector3 rawVelocity = (position - lastState.Position) / timeDelta;
                rawVelocity = Vector3.ClampMagnitude(rawVelocity, maxVelocity);
                velocity = Vector3.Lerp(lastState.Velocity, rawVelocity, 1f - velocityPredictionDamping);

                if (playerDiagnostics.ContainsKey(id))
                {
                    var diagnostics = playerDiagnostics[id];
                    float jitter = (rawVelocity - lastState.Velocity).magnitude / timeDelta;
                    if (jitter > 10f)
                    {
                        diagnostics.LastJitter = jitter;
                        diagnostics.JitterCount++;
                    }
                    playerDiagnostics[id] = diagnostics;
                }
            }
        }

        float currentRTT = Time.time - serverTimestamp;
        if (estimatedRTT.ContainsKey(id))
        {
            estimatedRTT[id] = Mathf.Lerp(estimatedRTT[id], currentRTT, 0.1f);
        }
        else
        {
            estimatedRTT[id] = currentRTT;
        }

        PlayerState newState = new PlayerState
        {
            Position = position,
            Rotation = rotation,
            ServerTimestamp = serverTimestamp > 0 ? serverTimestamp : Time.time,
            Velocity = velocity,
            ClientReceiveTime = Time.time
        };

        if (!stateBuffers.ContainsKey(id))
        {
            stateBuffers[id] = new Queue<PlayerState>();
        }
        stateBuffers[id].Enqueue(newState);

        int targetBufferSize = Mathf.RoundToInt(Mathf.Lerp(minStateBufferSize, maxStateBufferSize, rtt / 0.3f));
        while (stateBuffers[id].Count > targetBufferSize)
        {
            stateBuffers[id].Dequeue();
        }

        if (!replayBuffers.ContainsKey(id))
        {
            replayBuffers[id] = new Queue<(Vector3, float, float)>();
        }
        replayBuffers[id].Enqueue((position, rotation, Time.time));
        while (replayBuffers[id].Count > 0 && Time.time - replayBuffers[id].Peek().Timestamp > REPLAY_BUFFER_DURATION)
        {
            replayBuffers[id].Dequeue();
        }

        lastPacketTimes[id] = Time.time;
    }

    public void UpdateAllPositions(string[] parts)
    {
        try
        {
            if (parts.Length < 2)
            {
                return;
            }

            if (!float.TryParse(parts[1], out float serverTimestamp))
            {
                return;
            }

            float messageTime = Time.time;
            int updatesProcessed = 0;

            for (int i = 2; i < parts.Length; i += 5)
            {
                if (i + 4 >= parts.Length)
                {
                    break;
                }

                try
                {
                    if (!int.TryParse(parts[i], out int id))
                    {
                        continue;
                    }

                    if (id == GameNetworkManager.Instance.LocalPlayerID)
                    {
                        continue;
                    }

                    if (!float.TryParse(parts[i + 1], out float x) ||
                        !float.TryParse(parts[i + 2], out float y) ||
                        !float.TryParse(parts[i + 3], out float z) ||
                        !float.TryParse(parts[i + 4], out float rotation))
                    {
                        continue;
                    }

                    Vector3 position = new Vector3(x, y, z);

                    if (!otherPlayers.ContainsKey(id))
                    {
                        OtherPlayersManagerClient.Instance?.SpawnOtherPlayer(id, position, rotation, 0, 3, 0, 0);
                    }
                    else
                    {
                        UpdatePlayerPosition(id, position, rotation, serverTimestamp);
                    }

                    updatesProcessed++;
                }
                catch (System.Exception)
                {
                }
            }
        }
        catch (System.Exception)
        {
        }
    }

    public void AddOtherPlayer(int id, GameObject player)
    {
        otherPlayers[id] = player;
        PlayerState initialState = new PlayerState
        {
            Position = player.transform.position,
            Rotation = player.transform.eulerAngles.z,
            ServerTimestamp = Time.time + GameNetworkManager.Instance.serverTimeOffset,
            Velocity = Vector3.zero,
            ClientReceiveTime = Time.time
        };
        currentStates[id] = initialState;
        targetStates[id] = initialState;
        stateBuffers[id] = new Queue<PlayerState>();
        stateBuffers[id].Enqueue(initialState);
        replayBuffers[id] = new Queue<(Vector3, float, float)>();
        replayBuffers[id].Enqueue((initialState.Position, initialState.Rotation, Time.time));
        estimatedRTT[id] = 0.08f;
        lastPacketTimes[id] = Time.time;

        playerDiagnostics[id] = new PlayerDiagnostics
        {
            LastDesyncDistance = 0f,
            DesyncCount = 0,
            LastJitter = 0f,
            JitterCount = 0,
            TeleportCount = 0,
            AverageRTT = 0.08f,
            BufferUnderflowCount = 0,
            BufferOverflowCount = 0,
            LastUpdateTime = Time.time,
            LastCorrectionDistance = 0f,
            CorrectionCount = 0,
            LastOverCorrectionDistance = 0f,
            OverCorrectionCount = 0,
            NoPacketFrames = 0,
            CurrentFPS = currentFPS,
            CurrentCorrectionStrength = baseCorrectionSmoothing,
            CurrentBaseInterpTime = baseInterpTime,
            ReplayCorrectionCount = 0,
            LastReplayTime = 0f
        };

        autoAdjustedInterpTime[id] = baseInterpTime;
        autoAdjustedCorrectionSmoothing[id] = baseCorrectionSmoothing;
        autoAdjustedPredictionFactor[id] = basePredictionFactor;
        autoAdjustedVelocitySmoothing[id] = baseVelocitySmoothing;
    }

    public void RemoveOtherPlayer(int id)
    {
        otherPlayers.Remove(id);
        currentStates.Remove(id);
        targetStates.Remove(id);
        stateBuffers.Remove(id);
        replayBuffers.Remove(id);
        estimatedRTT.Remove(id);
        lastPacketTimes.Remove(id);
        lastDesyncTimes.Remove(id);
        lastCorrectionTimes.Remove(id);
        playerDiagnostics.Remove(id);
        autoAdjustedInterpTime.Remove(id);
        autoAdjustedCorrectionSmoothing.Remove(id);
        autoAdjustedPredictionFactor.Remove(id);
        autoAdjustedVelocitySmoothing.Remove(id);
    }

    public IEnumerable<int> GetOtherPlayerIDs()
    {
        return otherPlayers.Keys;
    }

    public GameObject GetOtherPlayer(int id)
    {
        return otherPlayers.ContainsKey(id) ? otherPlayers[id] : null;
    }
}
